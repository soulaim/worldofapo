const int MAX_LIGHTS = 71;
uniform vec4 lights[MAX_LIGHTS * 2];
const int POSITION = 0;
const int DIFFUSE = 1;

uniform vec4 activeLights;

varying vec2 texcoord;

uniform sampler2D texture_colors;
uniform sampler2D normals;
uniform sampler2D positions;
uniform sampler2D depthTexture;

const int MAX_ACTIVE_LIGHTS = 4;

uniform vec3 camera_position;
uniform vec3 camera_target;
varying vec3 fragment_direction;

uniform float light_count;

#define zFar 200.0
#define zNear 0.1

// Maps ]0,1[ to ]0,1[
float linearizeDepth(float z)
{
	float n = 0.1; // camera z near
	float f = 200.0; // camera z far
	return (2.0 * n) / (f + n - z * (f - n));
}

// Maps ]0,1[ to ]0,1[
float delinearizeDepth(float z)
{
	float a = zFar / ( zFar - zNear );
	float b = zFar * zNear / ( zNear - zFar );
	return a + b / z;
}

//#define OLD_LIGHTS

void main()
{
	vec4 light_color = vec4(0,0,0,1);
	vec4 texture_color = texture2D(texture_colors, texcoord);
	vec3 normal = texture2D(normals, texcoord).rgb;
	normal = 2.0 * normal - 1.0;
	vec4 fragment_position = texture2D(positions, texcoord);

	if(gl_FragCoord.x < 500.0)
	{
	//	gl_FragColor = vec4(normal*0.5 + 0.5,1); return;

		if(gl_FragCoord.y > 200.0)
		{
//			gl_FragColor = vec4(sin( normalize(fragment_position.xyz - camera_position) ),1); return;
//			gl_FragColor = vec4( length(fragment_position.xyz - camera_position) / (200.0 - 0.1)); return;
			vec3 camera_direction = normalize(camera_target - camera_position);
			float d = dot(camera_direction, fragment_position.xyz - camera_position);
			float real_z = delinearizeDepth(d);
			gl_FragColor = vec4(real_z); return;

//			gl_FragColor = vec4(sin(fragment_position.xyz),1); return;
		}

		float depth = texture2D(depthTexture, texcoord).r;
		float z = linearizeDepth(depth);
		gl_FragColor = vec4(z); return;

		vec3 frag_dir = normalize(fragment_direction - camera_position);
		gl_FragColor = vec4(sin(frag_dir),1); return;
		//vec3 pospos = camera_position + frag_dir;
	}


#ifdef OLD_LIGHTS
	int activeLight[MAX_ACTIVE_LIGHTS];
	activeLight[0] = int(activeLights.x);
	activeLight[1] = int(activeLights.y);
	activeLight[2] = int(activeLights.z);
	activeLight[3] = int(activeLights.w);

	for(int i = 0; i < MAX_ACTIVE_LIGHTS; ++i)
	{
		int lightIndex = activeLight[i];
#else
	int light_counti = int(light_count);
	for(int i = 0; i < light_counti; ++i)
	{
		int lightIndex = i;
#endif
		vec4 light_diffuse = lights[lightIndex*2 + DIFFUSE];
		vec4 light_position = lights[lightIndex*2 + POSITION];

		vec3 light_direction = vec3(gl_ModelViewMatrix * (light_position - fragment_position));

		float dist = length(light_direction);
		vec3 lightDir = normalize(light_direction);

		float NdotL = 1.0;
		if(dist > 0.0)
		{
			NdotL = dot(normal, normalize(lightDir));
		}

		if(NdotL > 0.0)
		{
			float att = 1.0 / (1.0 + 0.01 * dist * dist);
			light_color += light_diffuse * NdotL * att;
		}
	}
	
	gl_FragColor = texture_color * light_color;
}

