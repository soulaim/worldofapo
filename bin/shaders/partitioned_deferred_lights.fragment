const int MAX_LIGHTS = 71;
uniform vec4 lights[MAX_LIGHTS * 2];
const int POSITION = 0;
const int DIFFUSE = 1;

uniform float activeLight;

uniform sampler2D texture_colors;
uniform sampler2D normals;
uniform sampler2D positions;

const int MAX_ACTIVE_LIGHTS = 4;

uniform float screen_width;
uniform float screen_height;

varying vec2 texcoord;

void main()
{
	vec2 texcoord2 = texcoord * 2.0 - 1.0;
	if(texcoord2.x * texcoord2.x + texcoord2.y * texcoord2.y > 1.0)
	{
		discard;
	}

	vec2 real_texcoord = gl_FragCoord.xy / vec2(screen_width, screen_height);

	vec3 normal = texture2D(normals, real_texcoord).rgb;
	normal = 2.0 * normal - 1.0;
//	gl_FragColor = vec4(normal*0.5 + 0.5,1); return;
	if(length(normal) < 0.5)
	{
//		gl_FragColor = vec4(1,0,0,1); return;
		// Lights don't affect skybox.
		discard;
	}

	vec4 light_color = vec4(0,0,0,1);
	vec4 texture_color = texture2D(texture_colors, real_texcoord);

	vec4 fragment_position = texture2D(positions, real_texcoord);

	int lightIndex = int(activeLight);

	vec4 light_diffuse = lights[lightIndex*2 + DIFFUSE];
	vec4 light_position = lights[lightIndex*2 + POSITION];

	vec3 light_direction = vec3(gl_ModelViewMatrix * (light_position - fragment_position));

	float dist = length(light_direction);
	vec3 lightDir = normalize(light_direction);

	float NdotL = 1.0;
	if(dist > 0.0)
	{
		NdotL = dot(normal, normalize(lightDir));
	}
	
	if(NdotL > 0.0)
	{
		float att = 1.0 / (0.0001 + 0.0020 * dist * dist);
		light_color += light_diffuse * NdotL * att;
	}

	gl_FragColor = texture_color * light_color;
//	gl_FragColor = vec4(1,0,0,1);
}

